
Formada por comandos e funções.
Ex.: int <- é um comando.
     printf() <- é uma função. (Toda função é seguida por parênteses.)

A Linguagem C é por natureza estruturada.

---------xx---------

ESTRUTURA BÁSICA

*Diretivas para o processador
#include <- inclusão de bibliotecas, que contém as funções.

*Declaração de variáveis globais.

*Declaração da FUNÇÃO PRINCIPAL.
int main() {
*Declaração de variáveis locais da função main.
*Comandos da função main.
}

-----XX-----

VOCABULÁRIO

Declaração: faz-se declarações de identificadores.

Identificador: nomes usados para se fazer referências a variáveis, funções, rótulos e vários outros objetos 
definidos pelo usuário.

Tipo: quando declaramos identificadores de variáveis, deve-se dar a elas um tipo. 
Tipos principais de variáveis: 
-objetos de dados; 
-escalares; 
-aritméticos: inteiros ou flutuantes.

Função: entidade operacional básica.


-----xx-----

FUNÇÕES
Uma função é um trecho de programa independente com atribuições bem definidas.

Sintaxe de uma função:

-----
<tipo> <nome> (<parâmetros>)   <<-- parâmetro é uma inf. opcional.
[<tipos de parâmetros>]; <<-- quando existente, necessita declar o tipo

{
 <variáveis (locais)>;
 <instruções>;
}

---

Uso de protótipo: cria-se o protótipo ANTES da função 'main', e depois
dela, coloca-se a função e suas instruções


-----xx-----

STRINGS

Em estrutura de dados, string significa, de uma forma geral, uma sequência de caracteres.
Em linguagem de programação, string também significa um tipo de dados - os literais -, geralmente declarado 
como 'string'. Entretanto, para a linguagem C em particular, não existe este tipo de dado. Strings (para a 
linguagem C, simplesmente 'sequência de caracteres', e não tipo de dados, como mensionado anteriormente) são 
tratadas como um vetor do tipo 'char'. Esta matriz de caracteres é terminada sempre com o caractere de 
controle '\n' (caractere nulo).

-----

Leitura de Strings com 'scanf()' e 'fgets()'

A função scanf() faz a leitura dos dados do tipo char mas não aceita espaço em branco, vendo 
este como o carácter de controle \n, finalizando assim, a sequência de caracteres. Importante 
citar também que, para a leitura de strings, não é necessário colocar o '&', como quando é 
feito na leitura dos dados numéricos, por exemplo, com o '&' representando o endereço de 
memória da variável.
Já para utilizar a função fgets() (recomendável), deve-se informar três parâmetros, estes o
nome da matriz, tamanho da matriz, e o nome do buffer em uso (stdin). Portanto, a função fgets()
é escrita com a sintaxe: | fgets() (var, tam, stdin); |.
Em uma leitura de caracteres, tanto com 'scanf' como com 'fgets', não é necessário informar as
colunas desta sequência de uma string (um nome, por exemplo), sendo portanto, em contrapartida, 
necessário informar a linha, pois esta representa outra string - são sempre dispostas na 
horizontal (sequência de colunas de uma linha).

Obs.: leitura e impressão
Se um vetor (matriz unidimensional) de 'char' for declarado, tanto na LEITURA quanto na 
IMPRESSÃO deste, não será necessário informar a linha, pois, o sistema (incluindo compilador,
etc.) já sub-entende que há somente uma linha para as colunas (string). Entretanto, assim como 
não é necessário informar a quantidade de linhas na declaração (1), não será necessário também 
nestas duas operações. Esta é a forma com que, geralmente nós fazemos (SEM INFORMAR A LINHA
NA DECLARAÇÃO (já que é única) E NOS PROCESSOS DE LEITURA E IMPRESSÃO).

-----

Finalizando Leitura de Dados do Tipo 'char' 

Há três formas para se finalizar a leitura de uma matriz do tipo 'char', em que, na prática, 
o sistema entende como se o usuário tivesse pressionado o caractere de controle '\n':

*tecla <Enter>: uso normal;

*uso de <backspace>: a linguagem C não aceita este uso, vendo este como um '\n', interrompendo 
assim, a leitura do teclado;

*estouro do limite do tamanho do vetor: no momento da entrada dos caracteres, quando a
quantidade destes é maior do que o tamanho previamente estabelecido pelo programador, no 
momento da criação da matriz do tipo char.

-----

Observações

Na declaração de matrizes do tipo char, percebi que, com somente um colchetes (unidimensional),
como por exemplo em | char nome[20]; |, este representa somente as colunas do vetor, 
sub-entendendo-se que existe, ANTES deste e de forma OCULTA, um primeiro colchetes, informando 
assim, na declaração, apenas UMA LINHA para o vetor.
Sendo assim, na prática, é como se eu tivesse feito | char nome[1][20]; |, sendo então UMA 
linha e VINTE colunas.

-----xx-----

ESTRUTURA OU MATRIZ HETEROGÊNEA

Anteriormente, quando trabalhamos com matrizes, notamos que somente foi possível trabalharmos com um tipo de 
dado po matriz. Para solucionar essa deficiência, será utilizada uma estrutura de dados, denominada na 
linguagem C de 'struct' (também denominado de 'registro' por alguns autores), a qual consiste em trabalhar 
com vários dados (membros da estrutura) de TIPOS DIFERENTES em uma mesma tabela - a estrutura de dados, 
propriamente dita. Por essa razão, essa tabela (matriz) é heterogênea.

-----

Além de ser vista como uma matriz (heterogênea), dependendo do ponto de vista, a struct pode 
ser vista, analogicamente, como uma um tipo de dado (assim como int, float, char, etc.). Por 
exemplo, quando você cria um programa, no momento em que você a cria sua struct 
|| ex.: struct CADASTRO {} ||, neste momento você pode vê-la como uma matriz. Mais do que 
isso, você poderá vê-la como uma matriz HETEROGÊNEA, pois perceba que os campos criados dentro 
dessa matriz podem ser de tipos diferentes.
Entretanto, à partir do momento em que, no decorrer da criação de seu programa, você declara 
uma variável qualquer, em que a mesma seja do 'tipo' da sua struct 
|| ex.: struct CADASTRO ALUNO ||, ela pode ser vista como um tipo de dado.

-----xx-----

ARQUIVOS EM DISCO

Um arquivo em linguagme C é do tipo FILE, uma estrutura formada por elementos do mesmo tipo, 
dispostos de forma sequencial. Seu objetivo é fazer a comunicação entre a memória principal 
(RAM) e a secundária, por meio do programa e do sistema operacional.

-----

Sintaxe

FILE <*variável ponteiro>

<variável ponteiro> = fopen("nome do arquivo", "tipo de abertura");

fclose(<variável ponteiro>);
-----xx-----

Tipos de abertura
R = permite apenas abrir um arquivo texto para leitura de seus dados. É necessário que o 
arquivo exista.

W = permite abrir um arquivo texto para escrita ou CRIA um arquivo novo para ser trabalhado. 
Entretanto, caso o arquivo já exista, ele será recriado, perdendo assim, o arquivo 
anteriormente criado.

A = permite abrir um arquivo texto para escrita, permitindo acrescentar novos dados ao final 
dele. Caso o arquivo não exista, ele será criado.

